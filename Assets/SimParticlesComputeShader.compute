#pragma kernel CSMain

#define NUM_THREADS 64
#define SHARED_MEMORY_SIZE 256

float _SofteningSquared, _DeltaTime, _Damping;
uint _NumBodies;
float4 _GroupDim, _ThreadDim;
StructuredBuffer<float4> _ReadPos, _ReadVel;
RWStructuredBuffer<float4> _WritePos, _WriteVel;

groupshared float4 sharedPos[SHARED_MEMORY_SIZE];

#define WRAP(x,m) (((x)<m)?(x):(x-m))  
#define SX(i) sharedPos[i+_ThreadDim.x*threadID.y]

float3 bodyBodyInteraction(float3 ai, float4 bi, float4 bj) 
{
    float3 r;

    // r_ij  [3 FLOPS]
    r.x = bi.x - bj.x;
    r.y = bi.y - bj.y;
    r.z = bi.z - bj.z;

    // distSqr = dot(r_ij, r_ij) + EPS^2  [6 FLOPS]
    float distSqr = r.x * r.x + r.y * r.y + r.z * r.z;
    distSqr += _SofteningSquared;

    // invDistCube =1/distSqr^(3/2)  [4 FLOPS (2 mul, 1 sqrt, 1 inv)]
    float distSixth = distSqr * distSqr * distSqr;
    float invDistCube = 1.0f / sqrt(distSixth);
    
    // s = m_j * invDistCube [1 FLOP]
    float s = bj.w * invDistCube;

    // a_i =  a_i + s * r_ij [6 FLOPS]
    ai.x += r.x * s;
    ai.y += r.y * s;
    ai.z += r.z * s;

    return ai;
}

// This is the "tile_calculation" function from the GPUG3 article.
float3 gravitation(float4 pos, float3 accel, uint3 threadID)
{
    uint i;

    // Here we unroll the loop
    for (i = 0; i < _ThreadDim.x; ) 
    {
        accel = bodyBodyInteraction(accel, SX(i), pos); i += 1;
        accel = bodyBodyInteraction(accel, SX(i), pos); i += 1;
        accel = bodyBodyInteraction(accel, SX(i), pos); i += 1;
        accel = bodyBodyInteraction(accel, SX(i), pos); i += 1;
    }

    return accel;
}


float3 computeBodyForce(float4 pos, uint3 groupID, uint3 threadID)
{
    float3 acc = float3(0.0, 0.0, 0.0);
    
    uint p = _ThreadDim.x;
    uint q = _ThreadDim.y;
    uint n = _NumBodies;

    uint start = n/q * threadID.y;
    uint tile0 = start/(n/q);
    uint tile = tile0;
    uint finish = start + n/q;
    
    for (uint i = start; i < finish; i += p, tile++) 
    {
        sharedPos[threadID.x+_ThreadDim.x*threadID.y] =  _ReadPos[WRAP(groupID.x+tile, _GroupDim.x) * _ThreadDim.x + threadID.x];
        
        GroupMemoryBarrierWithGroupSync();
        // This is the "tile_calculation" function from the GPUG3 article.
        acc = gravitation(pos, acc, threadID);
        GroupMemoryBarrierWithGroupSync();
    }

	return acc;

}


[numthreads(NUM_THREADS,1,1)]
void CSMain (uint3 groupID : SV_GroupID, uint3 threadID : SV_GroupThreadID)
{
	uint index = groupID.x * NUM_THREADS + threadID.x;

	float4 pos = _ReadPos[index];
	float4 vel = _ReadVel[index];

	float3 force = computeBodyForce(pos, groupID, threadID);
	
	vel.xyz += force.xyz * _DeltaTime;
    vel.xyz *= _Damping;
 
    // new position = old position + velocity * deltaTime
    pos.xyz += vel.xyz * _DeltaTime;
	
	_WritePos[index] = pos;
	_WriteVel[index] = vel;
   
}


//This code was ported to direct compute from CUDA
//In cuda the terms for groups and threads are a bit different
//This is what I have changed, with the CUDA terms on the left
//Note - the direct compute terms I have used may not be the offical terms
//threadIdx = threadID
//blockIdx = groupID
//blockDim = threadDim
//gridDim = groupDim